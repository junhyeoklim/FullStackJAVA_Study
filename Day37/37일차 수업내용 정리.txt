1. 하나의 쓰레드만 깨우는 메소드 및 기다리게 하는 메소드 : notify,wait -> 동기화 블럭안에 작성한다

2. ReentrantLock - 새로 나온 동기화 방식
 - .lock으로 잠그고 .unlock으로 잠금 해제
 * 잠금 해제를 안 하게되면 큰 문제가 발생 하니 try-finally 방식으로 무조건 .unlock이 호출 되게 작성한다

** 동기화 관련 내용 **
-> lock이나 wait 구문을 어디다 써야 할지 계속 헷갈리는데
간단하게 정의를 다시금 생각 해보자
동기화는 여러 쓰레드들이 한꺼번에 접근 하지 못하게 막고 1개씩 접근 가능 하게 해주는 거기 떄문에 쓰레드가 접근 하는 부분
즉, 실습 예제들에서 쓰레드 부분 말고 기능 구현 한 클래스 그 부분에다가 작성 해주면 된다 라고 생각 하자




**
3. ReentrrankLockTest 실습 문제에서 
Reader rd = new Reader(str); 이 쓰레드가 먼저 실행 되고 있고
Condition 인터페이스에서 await는 wait 즉 현재 실행중이 쓰레드를 일시 중지 시키는 메소드이고 Reader 안에 await를 설정한
Condition 참조변수가 Reader의 쓰레드를 가르키게 된다.(아마도)

데이터 흐름을 보면 Reader 클래스가 먼저 실행 되고 입력 받은 문자열을 Reader에서 출력을 해야 하니 Reader Thread를
잠시 일시정지 시켜야 하므로

if(newCheck == false)
	write.await(); -> Condition의 참조 변수이고 이름은 크게 상관 없지만 가독성을 높이기 위해 write라고 써준다.
이 구문을 써준다
그 이후 Writer 쓰레드를 실행 시켜야 하므로 read.signal(); 를 썼다.

여러 테스트를 해봤는데 Writer 클래스에서 
			if(newCheck == true)
			{
				System.out.println("테스트2");
//				write.await();
			}
이 부분을 주석 처리 해도 정상적으로 작동 됐다
즉, 쓰레드의 실행 순서 정보를 알고 있으면 먼저 실행 되는 쓰레드 부분만 스위치 구문 처럼 쓰면 되고
다른 쓰레드 부분은 그냥 signal로 일시 중지 시킨 쓰레드를 꺠워 주면 된다.
(애초에 쓰레드 흐름은 알아내기 어렵기 때문에 편하게 둘다 구현 해주자)

4. 쓰레드 이름 설정 하는 방법
 - super("이름"); - 상위 클래스에 이름을 보낸다

5. 일반적으로 Runnable을 구현한 인스턴스 생성 방법을 많이 사용 한다
 : java는 다중 상속이 안되기 때문

6. 쓰레드 풀 : 쓰레드를 생성,소멸 시킬때 부하가 심하기 때문에 미리 만들어 놓은 쓰레드를 소멸시키지 않고 돌려 쓰는것
(직접 구현하기에는 쉽지 않지만 api 형태로 제공 되기 때문에 쓰는건 쉽다)

 - ExecutorService exr = Executors.newSingleThreadExecutor(); -> 이런식으로 선언

 - .submit() -> 전달
 - .shutdown - >종료 ->이미 하던 작업은 그대로 하고 추가로 작업을 전달 받지는 않는다.
 - Executors.newFixedThreadPool(2); -> 쓰레드 풀 2개 생성

6-1 Callable

        Callable<Integer> task = () -> {
            int sum = 0;
            for(int i = 0; i < 10; i++)
                sum += i;
            return sum;
        };
        
        ExecutorService exr = Executors.newSingleThreadExecutor();
        Future<Integer> fur = exr.submit(task);
        
        Integer r = fur.get();
        System.out.println("result: " + r);
        exr.shutdown();

대충 이런식으로 쓰인다.

6-2 exr.awaitTermination(100, TimeUnit.SECONDS); -> 쓰레드 풀이 바로 끝나버리지 않게 하기 위해서 딜레이 주는거

** 함수형 인터페이스(FunctionalInterface) - abstract가 1개(추상 메소드가 1개) - 람다로 구현 가능하다
