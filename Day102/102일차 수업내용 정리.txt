	<!-- 생략시 : scope = singletone -> 객체 1개 생성
	     prototype? : 호출 할 때마다 객체 생성 
	  -->


2. <!-- 	<bean id="samsungTV" class="polymorphism.SamsungTV">
		<property name="speaker" ref="speaker"></property>
		<property name="price" value="2700000"></property>
	</bean> --> 이런 방법도 있고
 - <bean id="samsungTV" class="polymorphism.SamsungTV" p:speaker-ref="speaker" p:price="2700000"/>
	이런 방법도 있다.(단, Namespaces에서 p를 추가하거나 beans xmlns에다가
	xmlns:p="http://www.springframework.org/schema/p" 이걸 추가해준다)



3.<bean id="tv" class="polymorphism.SamsungTV" lazy-init="true" init-method="initMethod" destroy-method="destroyMethod"/>

 *  lazy-init 속성
    ApplicationContext를 이용하여 컨테이너를 구동하면 컨테이너가 구동되는 시점에 
    스프링 설정 파일에 등록된 <bean>들을 생성하는 즉시 로딩 (pre-loading) 방식으로 동작한다. 

   그런데 어떤 <bean>은 자주 사용되지도 않으면서 메모리를 많이 차지하여 시스템에 부담을 주는 경우도 있다.

   따라서 스프링에서는 컨테이너가 구동되는 시점이 아닌 해당 <bean>이 사용되는 시점에 객체를 생성하도록
   init-lazy 속성을 제공한다. 특정 <bean>을 등록할 때, lazy-init="true"로 설정하면 
   스프링 컨테이너는 해당 <bean>을 미리 생성하지 않고 클라이언트가 요청하는 시점에
   생성한다. 결국, 메모리 관리를 더 효율적으로 할 수 있게 된다.


4. **<context:component-scan base-package="polymorphism"/>
   -> Namespace에 있는 context를 추가 해줘야 함
   -> polmorphism 밑에 있는 package중 @component가 설정 되어 있는 모든 것을 객체 생성 후 메모리에 올림
   -> @Component("tv") 이런식으로 이름을 안 주면 첫 글자가 소문자인 lgTV 이런식으로 생성 된다
   -> @Autowired -> ex) 메모리에 Speaker형 객체가 있으면 @Autowired speaker 여기다 집어 넣는다
   -> 만약 speaker 객체가 2개 이상 있을때 정확하게 구분하기 위해서 @Qualifier("apple") 이걸 쓴다
   -> 좀더 구체적인 설명
      (@Autowired 어노테이션은 Spring의 의존성 주입 기능을 사용하여 자동으로 빈을 주입합니다. 
       하지만 Spring이 자동으로 주입할 빈을 선택하는 과정에서 같은 타입의 빈이 여러 개 있는 경우 
       어떤 빈을 주입해야 할지 알 수 없어 오류가 발생할 수 있습니다. 
       이 때 @Qualifier 어노테이션을 사용하여 주입할 정확한 빈을 지정할 수 있습니다.)



5. @Resource() -> @Autowired+@Qualifier()

6. 결론:
    @Autowired: 가장 흔히 사용되며, Spring의 자동 주입 기능을 최대한 활용하고자 할 때 사용됩니다. 
                      @Qualifier와 함께 사용하여 특정 빈을 명확하게 지정할 수 있습니다.

    @Resource: 이름으로 의존성을 주입하고 싶을 때 사용합니다. 
                    예를 들어, 특정 이름의 리소스나 빈에 의존하는 경우, 또는 자동 주입을 통해 
                    타입이 아닌 이름으로 명확히 구분지어 주입할 때 유용합니다.

     @Autowired + @Qualifier: 특정 타입 내에서 더 세부적인 선택이 필요할 때 사용합니다. 
                                       @Autowired로 타입은 맞추고, @Qualifier로 구체적인 빈을 지정합니다.


7. 그럼 언제 어떻게 사용 하는데?

(1) 코드의 명확성과 의도
@Autowired는 타입에 기반하여 의존성을 주입하므로, 같은 타입의 빈이 여러 개 있을 경우 
어떤 것을 주입해야 할지 명확하지 않을 수 있습니다.
이 경우 @Qualifier를 추가하여 명확하게 해주는 것이 좋습니다.

@Resource는 이름으로 빈을 주입받으므로, 특정 빈을 명확히 지정할 때 유용합니다. 
이는 의존성 주입의 의도를 더 명확하게 표현할 수 있게 해줍니다.

(2) 유연성과 확장성
@Autowired와 @Qualifier의 조합은 Spring의 기본 기능을 최대한 활용하여 
유연하고 확장성 있는 코드를 작성할 수 있도록 돕습니다. 
예를 들어, 구성이 변경되어 다른 빈을 주입해야 할 때, 
XML 파일이나 Java 설정 클래스에서 빈의 정의만 변경하면 됩니다.

@Resource는 JSR-250 표준의 일부로, Spring 외의 다른 컨테이너에서도 사용될 수 있어 
표준 기반의 접근을 선호하는 경우 유용할 수 있습니다.

(3) 코드의 간결성
@Autowired는 별도의 지정자 없이도 대부분의 경우 잘 작동하여 코드를 간결하게 유지할 수 있습니다. 하지만, 명확성을 높이기 위해 필요한 경우 @Qualifier를 추가해야 할 수도 있습니다.
@Resource는 간단한 이름 기반 주입을 위해 한 줄로 처리할 수 있으며, 이 때문에 더 간결하게 사용될 수 있습니다.