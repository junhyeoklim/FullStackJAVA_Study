1. Optional.of() -> 내용물이 없는 객체 생성 불가능
 - Optional.ofNullable() -> 내용물이 없는 객체 생성 가능 

2. Optional<String> os2 = os1.map(s -> s.toUpperCase()); -> 리턴 값이 Optinal이다 *

3. Optional.empty();

4. orElse() -> 반환 타입 String

5. flatMap -> map이 Optional 객체 반환을 했다면 flatMap은 내용물 자체를 반환

6.Stream - 데이터의 흐름
 : 최종파이프,중간파이프 등이 있다.

 - 스트림의 생성 방법 : 배열 및 컬렉션 인스턴스 대상으로 스트림을 생성하는 방법
 - 중간 연산의 종류와 내용 : 필터링(Filtering) 및 맵핑(Mapping) 관련 연산
 - 최종 연산의 종류와 내용 : 리덕션(Reduction) 관련 연산


****************************************************************************************************************

1) Optional이 만들어진 이유와 의도

: Optional은 null을 반환하면 오류가 발생할 가능성이 매우 높은 경우에 
  '결과 없음'을 명확하게 드러내기 위해 메소드의 반환 타입으로 사용되도록 
  매우 제한적인 경우로 설계되었다는 것이다. 
  이러한 설계 목적에 부합하게 실제로 Optional을 잘못 사용하면 많은 부작용(Side Effect)이 발생하게 된다. 

  
2) Optional이 위험한 이유, Optional을 올바르게 사용해야 하는 이유 

 : Optional을 사용하면 코드가 Null-Safe해지고, 가독성이 좋아지며 애플리케이션이 안정적이 된다는 등과 같은 얘기들을
  많이 접할 수 있다. 하지만 이는 Optional을 목적에 맞게 올바르게 사용했을 때의 이야기이고, 
  Optional을 남발하는 코드는 오히려 다음과 같은 부작용(Side-Effect)를 유발할 수 있다.

 - NullPointerException 대신 NoSuchElementException가 발생함
 - 이전에는 없었던 새로운 문제들이 발생함 -> 직렬화 문제
 - 코드의 가독성을 떨어뜨림
 - 시간적, 공간적 비용(또는 오버헤드)이 증가함


3) 여러개의 객체를 직렬화하고 이를 역직렬화 한다면 주의해야할 사항

 : 역직렬화 할 때는 직렬화할 때의 순서와 일치 해야 된다는 점인데, 
   예를들어 객체 customer1, customer2, customer3 순서로 직렬화 했다면, 
   역직렬화 할 때도 customer1, customer2, customer3 의 순서로 받아야 된다. 
   (파일에 직렬화 순서대로 바이트 문자가 기재되어 지니 당연한 소리이긴 하다)

   따라서 직렬화할 객체가 많다면 ArrayList와 같은 컬렉션에 저장해서 관리 하는것이 좋다. 
   ArrayList 하나만 역직렬화하면 되므로 객체의 순서를 고려할 필요가 없어지기 때문이다.
