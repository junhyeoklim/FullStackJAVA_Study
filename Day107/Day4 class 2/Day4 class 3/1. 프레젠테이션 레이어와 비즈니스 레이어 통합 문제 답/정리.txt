사실 Controller는 비즈니스 컴포넌트를 이용하여 사용자의 요청을 처리해야 하며, 이때 컴포넌트가 제공하는 Service 인터페이스를 이용해야 한다. 지금처럼 Controller가 직접 DAO 객체의 메소드를 호출하도록 하면 안되며, 이는 여러 가지 문제를 일으킨다.

(1) DAO 클래스 교체하기
Controller 메소드에서 DAO의 메소드를 호출하면 안 되는 첫 번째 이유는 유지보수 과정에서 DAO 클래스를 다른 클래스로 쉽게 교체하기 위해서이다. 지금은 BoardController의 모든 메소드가 BoardDAO 객체를 매개변수로 받아서 DB 연동을 처리하고 있다. 그런데 DAO 클래스를 기존에 우리가 만들었던 BoardDAOSpring 으로 변경하거나 앞으로 추가될 다른 DAO 클래스로 변경하고자 한다면 BoardDAOSpring으로 변경하거나 앞으로 추가될 다른 DAO 클래스로 변경하고자 한다면 BoardController의 모든 메소드를 수정해야 한다.
그리고 BoardDAO클래스를 사용하는 Controller가 BoardController 클래스 하나면 상관없지만, 여러 개라면 해당 클래스들을 모두 열어서 일일이 매개변수를 수정해야 한다. 이렇게 비즈니스 컴포넌트가 변경되거나 새로운 요소가 추가될 때마다 이를 사용하는 Controller의 소스를 매번 수정한다면 유지보수는 어려울 수 밖에 없다.
그러면 비즈니스 컴포넌트가 수정되더라도 이를 사용하는 Controller는 수정하지 않아도 되게끔 하려면 어떻게 해야 할까? 비즈니스 컴포넌트 입장에서 자신을 사용해주는 클라이언트는 Controller이다. 클라이언트가 인터페이스를 통해서 비즈니스 컴포넌트를 이용하면 컴포넌트의 구현 클래스를 수정하거나 다른 클래스로 대체해도 이를 사용하는 클라이언트는 수정하지 않아도 된다. 이것이 다형성의 장점이자 객체지향 언어의 중요한 특징이다.

package com.springbook.view.board;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.SessionAttributes;

import com.springbook.biz.board.BoardVO;
import com.springbook.biz.board.impl.BoardService;

@Controller
@SessionAttributes("board")
public class BoardController {
	@Autowired
	private BoardService boardService;
	
	// 검색 조건 목록 설정
	@ModelAttribute("conditionMap")
	public Map<String, String> searchConditionMap() {
		Map<String, String> conditionMap = new HashMap<String, String>();
		conditionMap.put("제목", "TITLE");
		conditionMap.put("내용", "CONTENT");
		return conditionMap;
	}

	// 글 등록
	@RequestMapping(value="/insertBoard.do")
	public String insertBoard(BoardVO vo) {
		System.out.println("글 등록 처리");
		boardService.insertBoard(vo);
		return "getBoardList.do";
	}
	
	// 글 수정
	@RequestMapping("/updateBoard.do")
	public String updateBoard(@ModelAttribute("board") BoardVO vo) {
		System.out.println("글 수정 처리");
		
		boardService.updateBoard(vo);
		return "getBoardList.do";
	}
	
	// 글 삭제
	@RequestMapping("/deleteBoard.do")
	public String deleteBoard(BoardVO vo) {
		System.out.println("글 삭제 처리");
		
		boardService.deleteBoard(vo);
		return "getBoardList.do";
	}
	
	// 글 상세 조회
	@RequestMapping("/getBoard.do")
	public String getBoard(BoardVO vo, Model model) {
		System.out.println("글 상세 조회 처리");
		
//		System.out.println(model.asMap());

		model.addAttribute("board", boardService.getBoard(vo));		// Model 정보 저장
		return "getBoard.jsp";		// View 이름 리턴
	}	
	
	// 글 목록 검색
	@RequestMapping("/getBoardList.do")
	public String getBoardList(BoardVO vo, Model model) {
		System.out.println("글 목록 검색 처리");
		
		model.addAttribute("boardList", boardService.getBoardList(vo));		// Model 정보 저장 
    	return "getBoardList.jsp";							
	}	
}

우선 boardService라는 멤버변수를 선언했고, 변수 위에 @Autowired를 설정했으므로 BoardService 타입의 BoardServiceImpl 객체가 의존성 주입된다. 그리고 모든 메소드에서 매개변수로 선언된 BoardDAO를 제거했고, 대신 boardService 변수를 이용해서 비즈니스 컴포넌트를 사용하도록 수정했다.

이제 BoardServiceImpl 클래스의 멤버변수로 선언된 BoardDAO를 다른 DAO 클래스로 얼마든지 변경할 수 있다. BoardServiceImpl 클래스를 열어서 기존에 BoardDAOSpring 타입의 멤버변수를다음과 같이 수정해 보자.

@Service("boardService")
public class BoardServiceImpl implements BoardService{
	
	@Autowired
	private BoardDAOSpring boardDAO;

중요한 것은 이렇게 BoardServiceImpl 클래스에서 사용하는 DAO 클래스가 변경되어도 클라이언트에 해당하는 BoardController는 수정할 필요가 없다는 것이다. 이제 새로운 DAO클래스가 추가되더라도 Controller를 수정하지 않고 쉽게 적용할 수 있게 되었다.

이제 게시판을 실행해보면 @Autowired 에러가 발생한다.

@Autowired에서 에러가 발생된 이유

1. 클라이언트로부터 ".do" 요청이 들어오면 서블릿 컨테이너는 DispatcherServlet을 생성한다.
2. DispatcherServlet은 스프링 설정 파일인 presentation-layer.xml을 로딩하여
3. 스프링 컨테이너를 구동한다
4. 이때 BoardController 객체만 메모리에 생성되고 @Autowired로 의존성 주입할 BoardServiceImpl 객체는 생성되지 않는다.

결론은 BoardController보다 의존성 주입될 BoardServiceImpl 객체가 먼저 생성되어 있어야 하는 것이다. 하지만 presentation-layer.xml 파일에는 다음과 같이 Controller 객체들만 컴포넌트 스캔하도록 설정했기 때문에 BoardServiceImpl 객체는 생성되지 않는다.

<context:component-scan base-package="com.springbook.view"></context:component-scan>

결국, Controller보다 의존성 주입 대상이 되는 비즈니스 컴포넌트를 먼저 생성하려면 비즈니스 컴포넌트를 먼저 생성하는 또 다른 스프링 컨테이너가 필요하다. 그리고 이 컨테이너를 Controller를 메모리에 생성하는 컨테이너보다 먼저 구동하면 된다.