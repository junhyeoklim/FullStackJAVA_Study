1. map vs flatMap

 - map : map 메서드를 사용하면 단일 스트림 안의 요소를 원하는 특정 형태로 변환할 수 있습니다

 - flatMap : flatMap 메서드는 스트림의 형태가 배열과 같을 때, 모든 원소를 단일 원소 스트림으로 반환할 수 있습니다. 
	   flatMap의 결과로 단일 원소 스트림을 반환하기 때문에 
	   filter 메서드를 바로 체이닝하여 사용할 수 있습니다. 초기에 생성된 스트림이 배열인 경우에 매우 유용합니다.

 - 로직에서 Optional 이 연속적으로 리턴되는 경우에 flatMap 을 사용해야 한다.
 - 차이점은 mapper function 의 리턴 타입인데 flatMap 의 경우 리턴타입이 Optional 이어야 한다.

 * flatMap(List::stream)

 -  flatMap()은 스트림의 요소에 1:다 변형을 적용하고, 새로운 스트림으로 "평평하게 폅니다." 
    쉽게 말해, Stream 안에 여러개의 list가 있을 때 모든 것을 합쳐서 하나의 새로운 스트림으로 만들기 위해 사용합니다.




2. static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
	-> static <T> Stream<T> concat(Stream<T> a, Stream<T> b)

 - extends 쓴 이유 : 스트림을 연결 시키는 concat 메소드가 실행중에 값이 변경 되면 안되므로 extends로 제한 건것이다.


3. CollectParallelStringStream

        List<String> ls = ss.parallel()
                          .filter(s -> s.length() < 5)                          
                          .collect(
                              () -> new ArrayList<>(),
                              (c, s) -> c.add(s),
                              (lst1, lst2) -> lst1.addAll(lst2));

 - .collect : 3번째 인수 (lst1, lst2) -> lst1.addAll(lst2) 이 부분은 병렬 처리 할떄만 사용 하여 병렬 처리가 아닐때는
	   쓰이지 않지만 그렇다고 null값을 넣어주면 예외 처리가 발생하기 때문에 그냥 이렇게 쓴다.
